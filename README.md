# demhack3 BFP - Browser FingerPrinting

<a href="https://bfp-demo.ml/#/">Live Demo</a> **Только отключите AdBlock**

## О проекте
<sub>*Проект выполнен в рамках хакатона demhack 3, большое спасибо всем организаторам и команде (от лица того кто это пишет)*</sub>

Еще один веб-сервис и Proof of concept того, что для отслеживания пользователя и его посещений ресурса совершенно не обязтельно просить его залогиниться. Пользователь может заходить под VPN, может менять UserAgent-a, может сменить браузер или даже устройство, все равно используя только информацию находящуюся в открытом доступе и легко вытаскиваемую из браузера его можно идентифицировать. 

Проект визуализирует и структурирует данные, которые могут получить сайты при помощи технической информации, отправляемой при запросе, скриптов на клиентской стороне и API браузера. На основе полученной информации пользователю выдается уникальный идентификатор и его история посещений ресурса, идентификатор позволяет ему попробовать обмануть сервис поменяв что-то в получаемой сервисом информации.

***Дисклеймер: то что было написано, было написано за 2 дня, не судите строго***

<a href="https://bfp-demo.ml/#/">Live Demo</a> **Только отключите AdBlock**

## Реализовано
С места в карьер, хорошо работает на Chrome 93 и FF 92. У каждого браузера свое специфичное API, это не значит что работать не будет совсем, но некоторые метрики могут отвалиться. Добавить поддержку всех мы не успели

Вебсайт: 
- Сбор всевозможных метрик на клиенте:
  - Приложения установленные на устройства (не полный список);
  - Железо устройства (оперативная память, процессор, GPU);
 - Открытые порты (отключено, работает в FF на линуксе);
 - Информация о браузере и устройстве (размер экрана, версия и производитель браузера и т.д).
- Визуализация и взаимодействие с сервером : 
  - Отправка на сервер и визуализация собранных данных;
  - Великолепный дизайн.

Бэкенд: 
- API для обработки и хранения отпечатков пользователя;
- Поиск пользователей и их истории посещений по отпечатка.

## Структура в картинках
Принципиальным выбор технологий не был, все могло быть реализовано иначе.

Бэк: Golang

База: Postgresql

Фронт: Flutter

Метрики: JS
![image](https://user-images.githubusercontent.com/42908925/134066955-72c95ecb-63b2-4ceb-baf8-d5d3bd9202f6.png)

## Метрики
Сами скрипты можно найти в **frontend/web/metrics/**

### Сбор общей информации
Была взята готовая либа, которая уже хорошо справляется с поставленной задачей <a href="https://github.com/fingerprintjs/fingerprintjs">fingerprintjs</a>
Базовые но довольно тщательно собранные метрики, что-то не собирается, но пользователя идентифицировать позволяет

### Получение браузера
Был найден хороший пост на стеке, где на основе разных особенностей браузеров выявлялся конкретный. <a href="https://stackoverflow.com/a/9851769">Пост на стеке</a>

### Приложения на устройстве
Ищем приложения из заранее заданного пула, очень полезная штука, которая здорово облегчает крос-браузерную идентификацию пользователя.

Короткий концепт звучит так, используя deep linking ссылки типа "<a href="skype://">skype://</a>" пытаемся вызывать контекстное окно для открытия приложения, если появилось, значит приложение установлено. Делаем все это в отдельном окне.

<a href="https://fingerprintjs.com/blog/external-protocol-flooding/">Статья с концепцией</a>

А вот готовой либы для такого нет, пришлось переписать на js используя наработки из <a href="https://github.com/fingerprintjs/external-protocol-flooding/tree/master/packages/client/src/detector">live-demo</a> написанного на TypeScript.

### Сканирование localhost портов (Не работает под Chrome, отключено)
Опять же, очень хорошо для крос-браузерной идентификации.
Если коротко, лезем в открытый порт, лезем в закрытый порт, сравниваем время, открытый должен обрабатываться медленнее (проверяем несколько раз, для уверенности)
<a href="https://incolumitas.com/2021/01/10/browser-based-port-scanning/">Описание концепции</a>

### Сканирование расширений
Основная идея:
1. По id расширения, если знать какой-то файл, который в нем точно есть можно получить страницу.
2. Парсим id из стора
3. Качаем расширение как .crx архив, открываем из него manifest.json и ищем в нем статичный файл внутри web_accessible_resources
4. Делаем fetch chrome-extension://EXTENSION_ID/EXTENSION_STATIC_FILE если есть ответ - победа

Например для Google Переводчик
```
fetch('chrome-extension://aapbdbdomjkkjkaonfhkkikfgjllcleb/options.html').then(
  (response) => {
      console.log(response);
      if (response.ok) {
        console.log("OK!!!")
      }
  },
  () => {}
);
```

Id мы спарсили, скрипт лежит в /scripts/

## Реализовано в картинках
<img src="https://user-images.githubusercontent.com/42908925/134066154-9e49e01b-d2dd-4179-9938-b3e0c7f03c6f.png" width="75%">
<img src="https://user-images.githubusercontent.com/42908925/134066201-4d61293d-a7d8-47e0-8c92-31f2c3f32678.png" width="75%">


